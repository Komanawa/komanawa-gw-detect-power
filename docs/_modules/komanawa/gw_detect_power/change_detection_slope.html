
<!DOCTYPE html>


<html lang="en" data-content_root="../../../" data-theme="light">

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>komanawa.gw_detect_power.change_detection_slope &#8212; Komanawa-gw-detect-power v2.0.0 documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "light";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../../_static/styles/theme.css?digest=8d27b9dea8ad943066ae" rel="stylesheet" />
<link href="../../../_static/styles/bootstrap.css?digest=8d27b9dea8ad943066ae" rel="stylesheet" />
<link href="../../../_static/styles/pydata-sphinx-theme.css?digest=8d27b9dea8ad943066ae" rel="stylesheet" />

  
  <link href="../../../_static/vendor/fontawesome/6.5.1/css/all.min.css?digest=8d27b9dea8ad943066ae" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../../../_static/vendor/fontawesome/6.5.1/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../_static/vendor/fontawesome/6.5.1/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../_static/vendor/fontawesome/6.5.1/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=a746c00c" />
    <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css?v=eafc0fe6" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../../_static/scripts/bootstrap.js?digest=8d27b9dea8ad943066ae" />
<link rel="preload" as="script" href="../../../_static/scripts/pydata-sphinx-theme.js?digest=8d27b9dea8ad943066ae" />
  <script src="../../../_static/vendor/fontawesome/6.5.1/js/all.min.js?digest=8d27b9dea8ad943066ae"></script>

    <script src="../../../_static/documentation_options.js?v=aa039f9c"></script>
    <script src="../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = '_modules/komanawa/gw_detect_power/change_detection_slope';</script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="light">

  
  
  <a id="pst-skip-link" class="skip-link" href="#main-content">Skip to main content</a>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>
    Back to top
  </button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search the docs ..."
         aria-label="Search the docs ..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>
  
    <header class="bd-header navbar navbar-expand-lg bd-navbar">
<div class="bd-header__inner bd-page-width">
  <label class="sidebar-toggle primary-toggle" for="__primary">
    <span class="fa-solid fa-bars"></span>
  </label>
  
  
  <div class=" navbar-header-items__start">
    
      <div class="navbar-item">

  

<a class="navbar-brand logo" href="../../../index.html">
  
  
  
  
  
    
    
    
    <img src="../../../_static/ksl_for_latex.png" class="logo__image only-light" alt=""/>
    <script>document.write(`<img src="" class="logo__image only-dark" alt=""/>`);</script>
  
  
    <p class="title logo__title">Groundwater Detection Power Overview</p>
  
</a></div>
    
  </div>
  
  <div class=" navbar-header-items">
    
    <div class="me-auto navbar-header-items__center">
      
        <div class="navbar-item">
<nav class="navbar-nav">
  <ul class="bd-navbar-elements navbar-nav">
    
                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../../autoapi/komanawa/gw_detect_power/index.html">
                        Code documentation
                      </a>
                    </li>
                
  </ul>
</nav></div>
      
    </div>
    
    
    <div class="navbar-header-items__end">
      
        <div class="navbar-item navbar-persistent--container">
          

 <script>
 document.write(`
   <button class="btn navbar-btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script>
        </div>
      
      
        <div class="navbar-item"><ul class="navbar-icon-links navbar-nav"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/Komanawa-Solutions-Ltd/komanawa-gw-detect-power" title="View on GitHub" class="nav-link" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><span><i class="fa-brands fa-square-github fa-lg" aria-hidden="true"></i></span>
            <span class="sr-only">View on GitHub</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://www.linkedin.com/company/k%C5%8Dmanawa-solutions-ltd/" title="Follow us on LinkedIn" class="nav-link" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><span><i class="fa-brands fa-linkedin fa-lg" aria-hidden="true"></i></span>
            <span class="sr-only">Follow us on LinkedIn</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://www.komanawa.com" title="Komanawa Solutions Ltd." class="nav-link" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><img src="../../../_static/just_symbol.png" class="icon-link-image" alt="Komanawa Solutions Ltd."/></a>
        </li>
</ul></div>
      
    </div>
    
  </div>
  
  
    <div class="navbar-persistent--mobile">

 <script>
 document.write(`
   <button class="btn navbar-btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script>
    </div>
  

  
</div>

    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
        
      
      <div class="bd-sidebar-primary bd-sidebar hide-on-wide">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
      <div class="sidebar-header-items__center">
        
          <div class="navbar-item">
<nav class="navbar-nav">
  <ul class="bd-navbar-elements navbar-nav">
    
                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../../autoapi/komanawa/gw_detect_power/index.html">
                        Code documentation
                      </a>
                    </li>
                
  </ul>
</nav></div>
        
      </div>
    
    
    
      <div class="sidebar-header-items__end">
        
          <div class="navbar-item"><ul class="navbar-icon-links navbar-nav"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/Komanawa-Solutions-Ltd/komanawa-gw-detect-power" title="View on GitHub" class="nav-link" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><span><i class="fa-brands fa-square-github fa-lg" aria-hidden="true"></i></span>
            <span class="sr-only">View on GitHub</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://www.linkedin.com/company/k%C5%8Dmanawa-solutions-ltd/" title="Follow us on LinkedIn" class="nav-link" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><span><i class="fa-brands fa-linkedin fa-lg" aria-hidden="true"></i></span>
            <span class="sr-only">Follow us on LinkedIn</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://www.komanawa.com" title="Komanawa Solutions Ltd." class="nav-link" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><img src="../../../_static/just_symbol.png" class="icon-link-image" alt="Komanawa Solutions Ltd."/></a>
        </li>
</ul></div>
        
      </div>
    
  </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main">
        
        
          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item">



<nav aria-label="Breadcrumb">
  <ul class="bd-breadcrumbs">
    
    <li class="breadcrumb-item breadcrumb-home">
      <a href="../../../index.html" class="nav-link" aria-label="Home">
        <i class="fa-solid fa-home"></i>
      </a>
    </li>
    
    <li class="breadcrumb-item"><a href="../../index.html" class="nav-link">Module code</a></li>
    
    <li class="breadcrumb-item active" aria-current="page">komanawa.gw_...</li>
  </ul>
</nav>
</div>
      
    </div>
  
  
</div>
</div>
              
              
              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <h1>Source code for komanawa.gw_detect_power.change_detection_slope</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">simplification of Mike&#39;s code (utils.py power_sims) to propagate the uncertainty from various assumptions to the stats</span>
<span class="sd">power calcs</span>
<span class="sd">created matt_dumont</span>
<span class="sd">on: 18/05/23</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">stats</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">komanawa.gw_detect_power.base_detection_calculator</span> <span class="kn">import</span> <span class="n">BaseDetectionCalculator</span>

<span class="c1"># handle import of optional dependencies</span>
<span class="n">age_tools_imported</span> <span class="o">=</span> <span class="kc">True</span>
<span class="n">pyhomogeneity_imported</span> <span class="o">=</span> <span class="kc">True</span>
<span class="n">kendal_imported</span> <span class="o">=</span> <span class="kc">True</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">komanawa.gw_age_tools</span> <span class="kn">import</span> <span class="n">binary_exp_piston_flow_cdf</span><span class="p">,</span> <span class="n">predict_historical_source_conc</span><span class="p">,</span> <span class="n">make_age_dist</span><span class="p">,</span> <span class="n">check_age_inputs</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="n">binary_exp_piston_flow_cdf</span><span class="p">,</span> <span class="n">get_source_initial_conc_bepm</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
    <span class="n">age_tools_imported</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
        <span class="s1">&#39;age_tools not installed, age distribution related functions will be unavailable, to install run &#39;</span>
        <span class="s1">&#39;pip install git+https://github.com/Komanawa-Solutions-Ltd/gw_age_tools&#39;</span>
    <span class="p">)</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">pyhomogeneity</span> <span class="kn">import</span> <span class="n">pettitt_test</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="n">pettitt_test</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">pyhomogeneity_imported</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
        <span class="s1">&#39;pyhomogeneity not installed, pettitt_test will be unavailable, to install run &#39;</span>
        <span class="s1">&#39;pip install pyhomogeneity&#39;</span>
    <span class="p">)</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">komanawa.kendall_stats</span> <span class="kn">import</span> <span class="n">MannKendall</span><span class="p">,</span> <span class="n">MultiPartKendall</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="n">MannKendall</span><span class="p">,</span> <span class="n">MultiPartKendall</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
    <span class="n">kendal_imported</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
        <span class="s1">&#39;kendall_stats not installed, mann_kendall will be unavailable, to install run &#39;</span>
        <span class="s1">&#39;pip install git+https://github.com/Komanawa-Solutions-Ltd/kendall_multipart_kendall.git&#39;</span>
    <span class="p">)</span>


<div class="viewcode-block" id="DetectionPowerCalculator">
<a class="viewcode-back" href="../../../autoapi/komanawa/gw_detect_power/index.html#komanawa.gw_detect_power.change_detection_slope.DetectionPowerCalculator">[docs]</a>
<span class="k">class</span> <span class="nc">DetectionPowerCalculator</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The DetectionPowerCalculator has been depreciated in version v2.0.0. To retain the old capability use v1.0.0.</span>

<span class="sd">        :param args: dummy</span>
<span class="sd">        :param kwargs: dummy</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;The DetectionPowerCalculator has been depreciated in version&#39;</span>
                                  <span class="s1">&#39;v2.0.0. To retain the old capability use v1.0.0.&#39;</span><span class="p">)</span></div>

        <span class="c1"># Keynote as a place holder to refactor tests and others using the repo</span>


<div class="viewcode-block" id="DetectionPowerSlope">
<a class="viewcode-back" href="../../../autoapi/komanawa/gw_detect_power/index.html#komanawa.gw_detect_power.change_detection_slope.DetectionPowerSlope">[docs]</a>
<span class="k">class</span> <span class="nc">DetectionPowerSlope</span><span class="p">(</span><span class="n">BaseDetectionCalculator</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The DetectionPowerSlope class is used to calculate the power of a change detection test based on observing</span>
<span class="sd">    a slope in the concentration data. The user passes a True concentration time series and the power is calculated</span>
<span class="sd">    by adding many noise realisations to the concentration data and then running one of multiple change detection tests on the noisy</span>
<span class="sd">    data.</span>

<span class="sd">    The Power is calculated as the percentage (0-100) of simulations which detect a slope.</span>

<span class="sd">    :param significance_mode: significance mode to use, options:</span>

<span class="sd">             * linear-regression: linear regression of the concentration data from time 0 to the end change detected if p &lt; min_p_value</span>
<span class="sd">             * linear-regression-from-[max|min]: linear regression of the concentration data from the maximum concentration of the noise free concentration data to the end change detected if p &lt; min_p_value</span>
<span class="sd">             * mann-kendall: mann-kendall test of the concentration data from time 0 to the end, change detected if p &lt; min_p_value</span>
<span class="sd">             * mann-kendall-from-[max|min]: mann-kendall test of the concentration data from the maximum/minimum of the noise free concentration data to the end, change detected if p &lt; min_p_value</span>
<span class="sd">             * n-section-mann-kendall: 2+ part mann-kendall test to identify change points. if change points are detected then a change is detected</span>
<span class="sd">             * pettitt-test: pettitt test to identify change points. if change points are detected then a change is detected</span>

<span class="sd">    :param nsims: number of noise simulations to run for each change detection (e.g. nsims=1000, power= number of detected changes/1000 noise simulations)</span>
<span class="sd">    :param min_p_value: minimum p value to consider a change detected</span>
<span class="sd">    :param min_samples: minimum number of samples required, less than this number of samples will raise an exception</span>
<span class="sd">    :param expect_slope: expected slope of the concentration data, use depends on significance mode:</span>

<span class="sd">                          * linear-regression, linear-regression-from-max, mann-kendall, or mann-kendall-from-max:</span>
<span class="sd">                            * one of 1 (increasing), -1 (decreasing), or &#39;auto&#39; will match the slope of the concentration data before noise is added</span>

<span class="sd">                          * n-section-mann-kendall: expected trend in each part of the time series (1 increasing, -1 decreasing, 0 no trend)</span>
<span class="sd">                          * pettitt-test: not used.</span>

<span class="sd">    :param efficent_mode: bool, default = True, if True then</span>

<span class="sd">                         * For linear regression and MannKendall based tests:  run the test on the noise free data to see if any change can be detected, if no change is detected then the test will not be on the noisy data</span>
<span class="sd">                         * For MultiPartMannKendall test: the test will be run on the noise free data to detect best change points and then the test will be run on the noisy data for a smaller window centered on the True change point see: * mpmk_efficent_min, * mpmk_window</span>
<span class="sd">                         * For Pettitt Test:  Not implemented, will be ignored and a waring passed</span>

<span class="sd">    :param nparts: number of parts to use for the n-section-mann-kendall test (not used for other tests)</span>
<span class="sd">    :param min_part_size: minimum number of samples in each part for the n-section-mann-kendall test (not used for other tests)</span>
<span class="sd">    :param no_trend_alpha: alpha value to use for the no trend sections in the n-section-mann-kendall test trendless sections are only accepted if p &gt; no_trend_alpha (not used for other tests)</span>
<span class="sd">    :param mpmk_check_step: int or function, default = 1, number of samples to check for a change point in the MultiPartMannKendall test, used in both efficent_mode=True and efficent_mode=False if mpmk is a function it must take a single argument (n, number of samples) and return an integer check step</span>
<span class="sd">    :param mpmk_efficent_min: int, default = 10, minimum number of possible change points to assess only used if efficent_mode = True  The minimum number of breakpoints to test (mpmk_efficent_min) is always respected (i.e. if the window size is less than the minimum number of breakpoints to test, then the window size will be increased to the minimum number of breakpoints to test, but the space between breakpoints will still be defined by check_step). You can specify the exact number of breakpoints to check by setting mpmk_efficent_min=n breakpoints and setting mpmk_window=0</span>
<span class="sd">    :param mpmk_window: float, default = 0.05, define the window around the true detected change point to run the MultiPartMannKendall.  The detction window is defined as: (cp - mpmk_window*n, cp + mpmk_window*n) where cp is the detected change `point and n is the number of samples in the time series Whe`re both a mpmk_window and a check_step&gt;1 is passed the mpmk_window will be used to de`fine the window size and the check_step` will be used to define the step size within the window.`</span>
<span class="sd">    :param nsims_pettit: number of simulations to run for calc`ulating the pvalue of the pettitt test (not used for other tests)</span>
<span class="sd">    :param ncores: number of cores to use for multiprocessing, None will use all available cores</span>
<span class="sd">    :param log_level: logging level for multiprocessing subprocesses</span>
<span class="sd">    :param return_true_conc: return the true concentration time series for each simulation with power calcs (not supported with multiprocessing power calcs)</span>
<span class="sd">    :param return_noisy_conc_itters: int &lt;= nsims, default = 0 Number of noisy simulations to return. if 0 then no noisy simulations are returned, not supported with multiprocessing power calcs</span>
<span class="sd">    :param only_significant_noisy: bool if True then only return noisy simulations where a change was detected if there are fewer noisy simulations with changes detected than return_noisy_conc_itters all significant simulations will be returned. if there are no noisy simulations with changes detected then and empty dataframe is returned</span>
<span class="sd">    :param print_freq: None or int:  if None then no progress will be printed, if int then progress will be printed every print_freq simulations (n%print_freq==0)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">implemented_mrt_models</span> <span class="o">=</span> <span class="p">()</span>
    <span class="n">implemented_significance_modes</span> <span class="o">=</span> <span class="p">(</span>
        <span class="s1">&#39;linear-regression&#39;</span><span class="p">,</span>
        <span class="s1">&#39;linear-regression-from-max&#39;</span><span class="p">,</span>
        <span class="s1">&#39;linear-regression-from-min&#39;</span><span class="p">,</span>
        <span class="s1">&#39;mann-kendall&#39;</span><span class="p">,</span>
        <span class="s1">&#39;mann-kendall-from-max&#39;</span><span class="p">,</span>
        <span class="s1">&#39;mann-kendall-from-min&#39;</span><span class="p">,</span>
        <span class="s1">&#39;n-section-mann-kendall&#39;</span><span class="p">,</span>
        <span class="s1">&#39;pettitt-test&#39;</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">significance_mode</span><span class="o">=</span><span class="s1">&#39;linear-regression&#39;</span><span class="p">,</span> <span class="n">nsims</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">min_p_value</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">min_samples</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
                 <span class="n">expect_slope</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="n">efficent_mode</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">nparts</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">min_part_size</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">no_trend_alpha</span><span class="o">=</span><span class="mf">0.50</span><span class="p">,</span>
                 <span class="n">mpmk_check_step</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">mpmk_efficent_min</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">mpmk_window</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span>
                 <span class="n">nsims_pettit</span><span class="o">=</span><span class="mi">2000</span><span class="p">,</span>
                 <span class="n">ncores</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">log_level</span><span class="o">=</span><span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span> <span class="n">return_true_conc</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">return_noisy_conc_itters</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                 <span class="n">only_significant_noisy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">print_freq</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="k">assert</span> <span class="n">print_freq</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">print_freq</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span> <span class="s1">&#39;print_freq must be None or an integer&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">print_freq</span> <span class="o">=</span> <span class="n">print_freq</span>
        <span class="k">assert</span> <span class="n">significance_mode</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">implemented_significance_modes</span><span class="p">,</span> <span class="p">(</span><span class="sa">f</span><span class="s1">&#39;significance_mode </span><span class="si">{</span><span class="n">significance_mode</span><span class="si">}</span><span class="s1"> not &#39;</span>
                                                                          <span class="sa">f</span><span class="s1">&#39;implemented, must be one of &#39;</span>
                                                                          <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">implemented_significance_modes</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nsims_pettitt</span> <span class="o">=</span> <span class="n">nsims_pettit</span>
        <span class="k">if</span> <span class="n">significance_mode</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;linear-regression&#39;</span><span class="p">,</span> <span class="s1">&#39;linear-regression-from-max&#39;</span><span class="p">,</span> <span class="s1">&#39;linear-regression-from-min&#39;</span><span class="p">,</span>
                                 <span class="s1">&#39;mann-kendall&#39;</span><span class="p">,</span> <span class="s1">&#39;mann-kendall-from-max&#39;</span><span class="p">,</span> <span class="s1">&#39;mann-kendall-from-min&#39;</span><span class="p">]:</span>
            <span class="k">assert</span> <span class="n">expect_slope</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;expect_slope must be &quot;auto&quot;, 1, or -1&#39;</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">efficent_mode</span><span class="p">,</span> <span class="nb">bool</span><span class="p">),</span> <span class="s1">&#39;efficent_mode must be a boolean&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">efficent_mode</span> <span class="o">=</span> <span class="n">efficent_mode</span>

        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">only_significant_noisy</span><span class="p">,</span> <span class="nb">bool</span><span class="p">),</span> <span class="s1">&#39;only_significant_noisy must be a boolean&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">only_significant_noisy</span> <span class="o">=</span> <span class="n">only_significant_noisy</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">return_true_conc</span><span class="p">,</span> <span class="nb">bool</span><span class="p">),</span> <span class="s1">&#39;return_true_conc must be a boolean&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">return_true_conc</span> <span class="o">=</span> <span class="n">return_true_conc</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">return_noisy_conc_itters</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span> <span class="s1">&#39;return_noisy_conc_itters must be an integer&#39;</span>
        <span class="k">assert</span> <span class="n">return_noisy_conc_itters</span> <span class="o">&lt;=</span> <span class="n">nsims</span><span class="p">,</span> <span class="s1">&#39;return_noisy_conc_itters must be &lt;= nsims&#39;</span>
        <span class="k">assert</span> <span class="n">return_noisy_conc_itters</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;return_noisy_conc_itters must be &gt;= 0&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">return_noisy_conc_itters</span> <span class="o">=</span> <span class="n">return_noisy_conc_itters</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_power_from_max</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_power_from_min</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">significance_mode</span> <span class="o">==</span> <span class="s1">&#39;linear-regression&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">power_test</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_power_test_lr</span>
        <span class="k">elif</span> <span class="n">significance_mode</span> <span class="o">==</span> <span class="s1">&#39;linear-regression-from-max&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_power_from_max</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">power_test</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_power_test_lr</span>
        <span class="k">elif</span> <span class="n">significance_mode</span> <span class="o">==</span> <span class="s1">&#39;linear-regression-from-min&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_power_from_min</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">power_test</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_power_test_lr</span>
        <span class="k">elif</span> <span class="n">significance_mode</span> <span class="o">==</span> <span class="s1">&#39;mann-kendall&#39;</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">kendal_imported</span><span class="p">,</span> <span class="p">(</span>
                <span class="s1">&#39;cannot run mann-kendall test, kendall_stats not installed&#39;</span>
                <span class="s1">&#39;to install run:</span><span class="se">\n</span><span class="s1">&#39;</span>
                <span class="s1">&#39;pip install git+https://github.com/Komanawa-Solutions-Ltd/kendall_multipart_kendall.git&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">power_test</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_power_test_mann_kendall</span>
        <span class="k">elif</span> <span class="n">significance_mode</span> <span class="o">==</span> <span class="s1">&#39;mann-kendall-from-max&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_power_from_max</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">assert</span> <span class="n">kendal_imported</span><span class="p">,</span> <span class="p">(</span>
                <span class="s1">&#39;cannot run mann-kendall test, kendall_stats not installed&#39;</span>
                <span class="s1">&#39;to install run:</span><span class="se">\n</span><span class="s1">&#39;</span>
                <span class="s1">&#39;pip install git+https://github.com/Komanawa-Solutions-Ltd/kendall_multipart_kendall.git&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">power_test</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_power_test_mann_kendall</span>
        <span class="k">elif</span> <span class="n">significance_mode</span> <span class="o">==</span> <span class="s1">&#39;mann-kendall-from-min&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_power_from_min</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">assert</span> <span class="n">kendal_imported</span><span class="p">,</span> <span class="p">(</span>
                <span class="s1">&#39;cannot run mann-kendall test, kendall_stats not installed&#39;</span>
                <span class="s1">&#39;to install run:</span><span class="se">\n</span><span class="s1">&#39;</span>
                <span class="s1">&#39;pip install git+https://github.com/Komanawa-Solutions-Ltd/kendall_multipart_kendall.git&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">power_test</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_power_test_mann_kendall</span>
        <span class="k">elif</span> <span class="n">significance_mode</span> <span class="o">==</span> <span class="s1">&#39;n-section-mann-kendall&#39;</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">kendal_imported</span><span class="p">,</span> <span class="p">(</span>
                <span class="s1">&#39;cannot run mann-kendall test, kendall_stats not installed&#39;</span>
                <span class="s1">&#39;to install run:</span><span class="se">\n</span><span class="s1">&#39;</span>
                <span class="s1">&#39;pip install git+https://github.com/Komanawa-Solutions-Ltd/kendall_multipart_kendall.git&#39;</span><span class="p">)</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nparts</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span> <span class="s1">&#39;nparts must be an integer&#39;</span>
            <span class="k">assert</span> <span class="n">nparts</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;nparts must be greater than 1&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">kendall_mp_nparts</span> <span class="o">=</span> <span class="n">nparts</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">min_part_size</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span> <span class="s1">&#39;min_part_size must be an integer&#39;</span>
            <span class="k">assert</span> <span class="n">min_part_size</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;min_part_size must be greater than 1&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">kendall_mp_min_part_size</span> <span class="o">=</span> <span class="n">min_part_size</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">no_trend_alpha</span><span class="p">,</span> <span class="nb">float</span><span class="p">),</span> <span class="s1">&#39;no_trend_alpha must be a float&#39;</span>
            <span class="k">assert</span> <span class="n">no_trend_alpha</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">no_trend_alpha</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;no_trend_alpha must be between 0 and 1&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">kendall_mp_no_trend_alpha</span> <span class="o">=</span> <span class="n">no_trend_alpha</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">expect_slope</span><span class="p">))</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">kendall_mp_nparts</span><span class="p">,</span> <span class="s1">&#39;expect_slope must be of length nparts&#39;</span>
            <span class="k">assert</span> <span class="nb">set</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">expect_slope</span><span class="p">))</span><span class="o">.</span><span class="n">issubset</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;expect_slope must be 1 -1, or 0, got:</span><span class="si">{</span><span class="nb">set</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">expect_slope</span><span class="p">))</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

            <span class="c1"># mpmk_check_step</span>
            <span class="k">if</span> <span class="nb">callable</span><span class="p">(</span><span class="n">mpmk_check_step</span><span class="p">):</span>
                <span class="n">n</span> <span class="o">=</span> <span class="n">mpmk_check_step</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
                <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span> <span class="s1">&#39;if mpmk_check_step is a function must return an integer&#39;</span>
                <span class="k">assert</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;if mpmk_check_step is a function must return an integer greater than 0&#39;</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mpmk_check_step</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="k">assert</span> <span class="n">mpmk_check_step</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;mpmk_check_step must be greater than 0&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;mpmk_check_step must be an integer or function&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mpmk_check_step</span> <span class="o">=</span> <span class="n">mpmk_check_step</span>

            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">efficent_mode</span><span class="p">,</span> <span class="nb">bool</span><span class="p">),</span> <span class="s1">&#39;efficent_mode must be a boolean&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">efficent_mode</span> <span class="o">=</span> <span class="n">efficent_mode</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mpmk_efficent_min</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span> <span class="s1">&#39;mpmk_efficent_min must be an integer&#39;</span>
            <span class="k">assert</span> <span class="n">mpmk_efficent_min</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;mpmk_efficent_min must be greater than 0&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mpmpk_efficent_min</span> <span class="o">=</span> <span class="n">mpmk_efficent_min</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mpmk_window</span><span class="p">,</span> <span class="nb">float</span><span class="p">),</span> <span class="s1">&#39;mpmk_window must be a float&#39;</span>
            <span class="k">assert</span> <span class="n">mpmk_window</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">mpmk_window</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">nparts</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;mpmk_window must be between 0 and </span><span class="si">{</span><span class="mi">1</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">nparts</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mpmk_window</span> <span class="o">=</span> <span class="n">mpmk_window</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">power_test</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_power_test_mp_kendall</span>
        <span class="k">elif</span> <span class="n">significance_mode</span> <span class="o">==</span> <span class="s1">&#39;pettitt-test&#39;</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">pyhomogeneity_imported</span><span class="p">,</span> <span class="p">(</span>
                <span class="s1">&#39;cannot run pettitt test, pyhomogeneity not installed&#39;</span>
                <span class="s1">&#39;to install run:</span><span class="se">\n</span><span class="s1">&#39;</span>
                <span class="s1">&#39;pip install pyhomogeneity&#39;</span><span class="p">)</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nsims_pettit</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span> <span class="s1">&#39;nsims_pettit must be an integer&#39;</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">efficent_mode</span><span class="p">,</span> <span class="nb">bool</span><span class="p">),</span> <span class="s1">&#39;efficent_mode must be a boolean&#39;</span>
            <span class="k">if</span> <span class="n">efficent_mode</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;efficent_mode not implemented for pettitt test, setting efficent_mode=False&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">efficent_mode</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># TODO long term fix this if needed</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">power_test</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_power_test_pettitt</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;significance_mode </span><span class="si">{</span><span class="n">significance_mode</span><span class="si">}</span><span class="s1"> not implemented, shouldnt get here&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">expect_slope</span> <span class="o">=</span> <span class="n">expect_slope</span>

        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nsims</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span> <span class="s1">&#39;nsims must be an integer&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nsims</span> <span class="o">=</span> <span class="n">nsims</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">min_samples</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span> <span class="s1">&#39;min_samples must be an integer&#39;</span>
        <span class="k">assert</span> <span class="n">min_samples</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;min_samples must be at least 3 otherwise the slope regresion will either&#39;</span>
                                  <span class="s1">&#39;fail or be meaningless&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_samples</span> <span class="o">=</span> <span class="n">min_samples</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_p_value</span> <span class="o">=</span> <span class="n">min_p_value</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_p_value</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_p_value</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;min_p_value must be between 0 and 1&#39;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ncores</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="n">ncores</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;ncores must be an integer or None&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ncores</span> <span class="o">=</span> <span class="n">ncores</span>
        <span class="k">assert</span> <span class="n">log_level</span> <span class="ow">in</span> <span class="p">[</span><span class="n">logging</span><span class="o">.</span><span class="n">CRITICAL</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">FATAL</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">ERROR</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">WARNING</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">WARN</span><span class="p">,</span>
                             <span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">],</span> <span class="sa">f</span><span class="s1">&#39;unknown log_level </span><span class="si">{</span><span class="n">log_level</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log_level</span> <span class="o">=</span> <span class="n">log_level</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">significance_mode</span> <span class="o">=</span> <span class="n">significance_mode</span>

<div class="viewcode-block" id="AutoDetectionPowerSlope.plot_iteration">
<a class="viewcode-back" href="../../../autoapi/komanawa/gw_detect_power/index.html#komanawa.gw_detect_power.change_detection_slope.AutoDetectionPowerSlope.plot_iteration">[docs]</a>
<div class="viewcode-block" id="DetectionPowerSlope.plot_iteration">
<a class="viewcode-back" href="../../../autoapi/komanawa/gw_detect_power/index.html#komanawa.gw_detect_power.change_detection_slope.DetectionPowerSlope.plot_iteration">[docs]</a>
    <span class="k">def</span> <span class="nf">plot_iteration</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">true_conc</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        plot the concentration data itteration and the true concentration data if provided as well as the power test results and any predictions from the power test (e.g. the slope of the line used)</span>

<span class="sd">        :param y0: noisy concentration data</span>
<span class="sd">        :param true_conc: true concentration data</span>
<span class="sd">        :return: fig, ax</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">istart</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
        <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">get_figure</span><span class="p">()</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y0</span><span class="p">)),</span> <span class="n">y0</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;noisy data&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">true_conc</span><span class="p">)),</span> <span class="n">true_conc</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;True data&#39;</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">significance_mode</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;linear-regression&#39;</span><span class="p">,</span> <span class="s1">&#39;linear-regression-from-max&#39;</span><span class="p">,</span> <span class="s1">&#39;linear-regression-from-min&#39;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_power_from_max</span><span class="p">:</span>
                <span class="n">istart</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">true_conc</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_power_from_min</span><span class="p">:</span>
                <span class="n">istart</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">true_conc</span><span class="p">)</span>
            <span class="n">o2</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">linregress</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y0</span><span class="p">))[</span><span class="n">istart</span><span class="p">:],</span> <span class="n">y0</span><span class="p">[</span><span class="n">istart</span><span class="p">:])</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y0</span><span class="p">))[</span><span class="n">istart</span><span class="p">:],</span> <span class="n">o2</span><span class="o">.</span><span class="n">intercept</span> <span class="o">+</span> <span class="n">o2</span><span class="o">.</span><span class="n">slope</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y0</span><span class="p">))[</span><span class="n">istart</span><span class="p">:],</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">,</span>
                    <span class="n">ls</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;regression, p=</span><span class="si">{:.3f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">o2</span><span class="o">.</span><span class="n">pvalue</span><span class="p">))</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">significance_mode</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;mann-kendall&#39;</span><span class="p">,</span> <span class="s1">&#39;mann-kendall-from-max&#39;</span><span class="p">,</span> <span class="s1">&#39;mann-kendall-from-min&#39;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_power_from_max</span><span class="p">:</span>
                <span class="n">istart</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">true_conc</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_power_from_min</span><span class="p">:</span>
                <span class="n">istart</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">true_conc</span><span class="p">)</span>
            <span class="n">mk</span> <span class="o">=</span> <span class="n">MannKendall</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">y0</span><span class="p">[</span><span class="n">istart</span><span class="p">:],</span> <span class="n">alpha</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">min_p_value</span><span class="p">)</span>
            <span class="n">mk</span><span class="o">.</span><span class="n">plot_data</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">significance_mode</span> <span class="o">==</span> <span class="s1">&#39;n-section-mann-kendall&#39;</span><span class="p">:</span>
            <span class="n">mpmk</span> <span class="o">=</span> <span class="n">MultiPartKendall</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">y0</span><span class="p">,</span> <span class="n">nparts</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">kendall_mp_nparts</span><span class="p">,</span>
                                    <span class="n">expect_part</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">expect_slope</span><span class="p">,</span> <span class="n">min_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">kendall_mp_min_part_size</span><span class="p">,</span>
                                    <span class="n">alpha</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">min_p_value</span><span class="p">,</span> <span class="n">no_trend_alpha</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">kendall_mp_no_trend_alpha</span><span class="p">)</span>
            <span class="n">bp</span> <span class="o">=</span> <span class="n">mpmk</span><span class="o">.</span><span class="n">get_maxz_breakpoints</span><span class="p">(</span><span class="n">raise_on_none</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">bp</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;no breakpoints found, not plotting multipart mann kendall&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mpmk</span><span class="o">.</span><span class="n">plot_data_from_breakpoints</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">significance_mode</span> <span class="o">==</span> <span class="s1">&#39;pettitt-test&#39;</span><span class="p">:</span>
            <span class="n">h</span><span class="p">,</span> <span class="n">cp</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">U</span><span class="p">,</span> <span class="n">mu</span> <span class="o">=</span> <span class="n">pettitt_test</span><span class="p">(</span><span class="n">y0</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">min_p_value</span><span class="p">,</span>
<div class="viewcode-block" id="AutoDetectionPowerSlope.truets_from_binary_exp_piston_flow">
<a class="viewcode-back" href="../../../autoapi/komanawa/gw_detect_power/index.html#komanawa.gw_detect_power.change_detection_slope.AutoDetectionPowerSlope.truets_from_binary_exp_piston_flow">[docs]</a>
<div class="viewcode-block" id="DetectionPowerSlope.truets_from_binary_exp_piston_flow">
<a class="viewcode-back" href="../../../autoapi/komanawa/gw_detect_power/index.html#komanawa.gw_detect_power.change_detection_slope.DetectionPowerSlope.truets_from_binary_exp_piston_flow">[docs]</a>
                                           <span class="n">sim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nsims_pettitt</span><span class="p">)</span>
            <span class="n">p</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">cp</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;change_point, </span><span class="si">{</span><span class="n">p</span><span class="si">=}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;unknown significance_mode </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">significance_mode</span><span class="si">}</span><span class="s1">, should not get here&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">istart</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="n">istart</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s1">&#39;:&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;start of power test&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span></div>
</div>


    <span class="k">def</span> <span class="nf">_power_test_lr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idv</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">expected_slope</span><span class="p">,</span> <span class="n">imax</span><span class="p">,</span> <span class="n">imin</span><span class="p">,</span> <span class="n">true_data</span><span class="p">,</span> <span class="n">return_slope</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        power calculations, probability of detecting a change via linear regression (slope is significant and in the correct direction)</span>

<span class="sd">        :param idv: identifier for the power calc site</span>
<span class="sd">        :param y: np.array of shape (nsims, n_samples)</span>
<span class="sd">        :param expected_slope: used to determine sign of slope predicted is same as expected</span>
<span class="sd">        :param imax: index of the maximum concentration</span>
<span class="sd">        :param imin: index of the minimum concentration</span>
<span class="sd">        :param return_slope: return the slope of the concentration data used to calculate expect slope</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_samples0</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_power_from_max</span><span class="p">:</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="p">[:,</span> <span class="n">imax</span><span class="p">:]</span>
            <span class="n">true_data</span> <span class="o">=</span> <span class="n">true_data</span><span class="p">[</span><span class="n">imax</span><span class="p">:]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_power_from_min</span><span class="p">:</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="p">[:,</span> <span class="n">imin</span><span class="p">:]</span>
            <span class="n">true_data</span> <span class="o">=</span> <span class="n">true_data</span><span class="p">[</span><span class="n">imin</span><span class="p">:]</span>
        <span class="n">n_sims</span><span class="p">,</span> <span class="n">n_samples</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">assert</span> <span class="n">n_samples</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_samples</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;n_samples must be greater than min_samples, &#39;</span>
                                               <span class="s1">&#39;raised here that means that the max concentration is too far along&#39;</span>
                                               <span class="sa">f</span><span class="s1">&#39;the timeseries to be detected: </span><span class="si">{</span><span class="n">imax</span><span class="si">=}</span><span class="s1">, </span><span class="si">{</span><span class="n">n_samples0</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_samples</span><span class="p">)</span>
        <span class="n">p_val</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">slopes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">efficent_mode</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">return_slope</span><span class="p">:</span>
            <span class="n">o2</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">linregress</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">true_data</span><span class="p">)</span>
            <span class="n">pval_bad</span> <span class="o">=</span> <span class="n">o2</span><span class="o">.</span><span class="n">pvalue</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_p_value</span>
            <span class="n">sign_bad</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">expected_slope</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">sign_bad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">o2</span><span class="o">.</span><span class="n">slope</span><span class="p">)</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">expected_slope</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">pval_bad</span> <span class="ow">or</span> <span class="n">sign_bad</span><span class="p">:</span>  <span class="c1"># cannot reject null hypothesis on noise free data</span>
                <span class="k">return</span> <span class="mf">0.</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_sims</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">y0</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">print_freq</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">print_freq</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">idv</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s1"> of </span><span class="si">{</span><span class="n">n_sims</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">o2</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">linregress</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y0</span><span class="p">)</span>
            <span class="n">slopes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">o2</span><span class="o">.</span><span class="n">slope</span><span class="p">)</span>
            <span class="n">p_val</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">o2</span><span class="o">.</span><span class="n">pvalue</span><span class="p">)</span>
        <span class="n">p_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">p_val</span><span class="p">)</span>
        <span class="n">slopes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">slopes</span><span class="p">)</span>
        <span class="n">p_list</span> <span class="o">=</span> <span class="n">p_val</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_p_value</span>
        <span class="k">if</span> <span class="n">expected_slope</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sign_corr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">slopes</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">expected_slope</span><span class="p">)</span>
            <span class="n">p_list</span> <span class="o">=</span> <span class="n">p_list</span> <span class="o">&amp;</span> <span class="n">sign_corr</span>
        <span class="n">power</span> <span class="o">=</span> <span class="n">p_list</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="n">n_sims</span> <span class="o">*</span> <span class="mi">100</span>

        <span class="k">if</span> <span class="n">return_slope</span><span class="p">:</span>
            <span class="n">slope_out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanmedian</span><span class="p">(</span><span class="n">slopes</span><span class="p">[</span><span class="n">p_list</span><span class="p">]))</span>
            <span class="k">return</span> <span class="n">power</span><span class="p">,</span> <span class="n">p_list</span><span class="p">,</span> <span class="n">slope_out</span>
        <span class="k">return</span> <span class="n">power</span><span class="p">,</span> <span class="n">p_list</span>

    <span class="k">def</span> <span class="nf">_power_test_mann_kendall</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idv</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">expected_slope</span><span class="p">,</span> <span class="n">imax</span><span class="p">,</span> <span class="n">imin</span><span class="p">,</span> <span class="n">true_data</span><span class="p">,</span>
                                 <span class="n">return_slope</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        power calculations, probability of detecting a change via linear regression</span>
<span class="sd">        (slope is significant and in the correct direction)</span>
<span class="sd">        :param y: np.array of shape (nsims, n_samples)</span>
<span class="sd">        :param expected_slope: used to determine sign of slope predicted is same as expected</span>
<span class="sd">        :param imax: index of the maximum concentration</span>
<span class="sd">        :param imin: index of the minimum concentration</span>
<span class="sd">        :param return_slope: return the slope of the concentration data used to calculate expect slope</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_samples0</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_power_from_max</span><span class="p">:</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="p">[:,</span> <span class="n">imax</span><span class="p">:]</span>
            <span class="n">true_data</span> <span class="o">=</span> <span class="n">true_data</span><span class="p">[</span><span class="n">imax</span><span class="p">:]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_power_from_min</span><span class="p">:</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="p">[:,</span> <span class="n">imin</span><span class="p">:]</span>
            <span class="n">true_data</span> <span class="o">=</span> <span class="n">true_data</span><span class="p">[</span><span class="n">imin</span><span class="p">:]</span>
        <span class="n">n_sims</span><span class="p">,</span> <span class="n">n_samples</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">assert</span> <span class="n">n_samples</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_samples</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;n_samples must be greater than min_samples, &#39;</span>
                                               <span class="s1">&#39;raised here that means that the max concentration is too far along&#39;</span>
                                               <span class="sa">f</span><span class="s1">&#39;the timeseries to be detected: </span><span class="si">{</span><span class="n">imax</span><span class="si">=}</span><span class="s1">, </span><span class="si">{</span><span class="n">n_samples0</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">efficent_mode</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">return_slope</span><span class="p">:</span>
            <span class="n">mk</span> <span class="o">=</span> <span class="n">MannKendall</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">true_data</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">min_p_value</span><span class="p">)</span>
            <span class="n">pval_bad</span> <span class="o">=</span> <span class="n">mk</span><span class="o">.</span><span class="n">p</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_p_value</span>
            <span class="n">sign_bad</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">expected_slope</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">sign_bad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">mk</span><span class="o">.</span><span class="n">trend</span><span class="p">)</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">expected_slope</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">pval_bad</span> <span class="ow">or</span> <span class="n">sign_bad</span><span class="p">:</span>  <span class="c1"># cannot reject null hypothesis on noise free data</span>
                <span class="k">return</span> <span class="mf">0.</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_sims</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

        <span class="n">p_val</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">slopes</span> <span class="o">=</span> <span class="p">[]</span></div>
</div>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">y0</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">print_freq</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
<div class="viewcode-block" id="AutoDetectionPowerSlope.truets_from_piston_flow">
<a class="viewcode-back" href="../../../autoapi/komanawa/gw_detect_power/index.html#komanawa.gw_detect_power.change_detection_slope.AutoDetectionPowerSlope.truets_from_piston_flow">[docs]</a>
<div class="viewcode-block" id="DetectionPowerSlope.truets_from_piston_flow">
<a class="viewcode-back" href="../../../autoapi/komanawa/gw_detect_power/index.html#komanawa.gw_detect_power.change_detection_slope.DetectionPowerSlope.truets_from_piston_flow">[docs]</a>
                <span class="k">if</span> <span class="n">i</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">print_freq</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">idv</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s1"> of </span><span class="si">{</span><span class="n">n_sims</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">mk</span> <span class="o">=</span> <span class="n">MannKendall</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">y0</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">min_p_value</span><span class="p">)</span>
            <span class="n">slopes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mk</span><span class="o">.</span><span class="n">trend</span><span class="p">)</span>
            <span class="n">p_val</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mk</span><span class="o">.</span><span class="n">p</span><span class="p">)</span>
        <span class="n">p_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">p_val</span><span class="p">)</span>
        <span class="n">slopes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">slopes</span><span class="p">)</span>
        <span class="n">p_list</span> <span class="o">=</span> <span class="n">p_val</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_p_value</span>
        <span class="k">if</span> <span class="n">expected_slope</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sign_corr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">slopes</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">expected_slope</span><span class="p">)</span>
            <span class="n">p_list</span> <span class="o">=</span> <span class="n">p_list</span> <span class="o">&amp;</span> <span class="n">sign_corr</span>
        <span class="n">power</span> <span class="o">=</span> <span class="n">p_list</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="n">n_sims</span> <span class="o">*</span> <span class="mi">100</span>
        <span class="n">slope_out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanmedian</span><span class="p">(</span><span class="n">slopes</span><span class="p">[</span><span class="n">p_list</span><span class="p">]))</span>

        <span class="k">if</span> <span class="n">return_slope</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">power</span><span class="p">,</span> <span class="n">p_list</span><span class="p">,</span> <span class="n">slope_out</span>
        <span class="k">return</span> <span class="n">power</span><span class="p">,</span> <span class="n">p_list</span>

    <span class="k">def</span> <span class="nf">_power_test_pettitt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idv</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">expected_slope</span><span class="p">,</span> <span class="n">imax</span><span class="p">,</span> <span class="n">imin</span><span class="p">,</span> <span class="n">true_data</span><span class="p">,</span> <span class="n">return_slope</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        :param y:data</span>
<span class="sd">        :param expected_slope: not used</span>
<span class="sd">        :param imax: not used</span>
<span class="sd">        :param imin: not used</span>
<span class="sd">        :param return_slope: not really used, dummy</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_sims</span><span class="p">,</span> <span class="n">n_samples</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">assert</span> <span class="n">n_samples</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_samples</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;n_samples must be greater than min_samples&#39;</span><span class="p">)</span>
        <span class="n">num_pass</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">passed</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">y0</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">print_freq</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">print_freq</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">idv</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s1"> of </span><span class="si">{</span><span class="n">n_sims</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">h</span><span class="p">,</span> <span class="n">cp</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">U</span><span class="p">,</span> <span class="n">mu</span> <span class="o">=</span> <span class="n">pettitt_test</span><span class="p">(</span><span class="n">y0</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">min_p_value</span><span class="p">,</span>
                                           <span class="n">sim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nsims_pettitt</span><span class="p">)</span>
            <span class="n">num_pass</span> <span class="o">+=</span> <span class="n">h</span>
            <span class="n">passed</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>
        <span class="n">passed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">passed</span><span class="p">)</span>
        <span class="n">power</span> <span class="o">=</span> <span class="n">num_pass</span> <span class="o">/</span> <span class="n">n_sims</span> <span class="o">*</span> <span class="mi">100</span>
        <span class="k">if</span> <span class="n">return_slope</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">power</span><span class="p">,</span> <span class="n">passed</span><span class="p">,</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">power</span><span class="p">,</span> <span class="n">passed</span>

    <span class="k">def</span> <span class="nf">_power_test_mp_kendall</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idv</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">expected_slope</span><span class="p">,</span> <span class="n">imax</span><span class="p">,</span> <span class="n">imin</span><span class="p">,</span> <span class="n">true_data</span><span class="p">,</span>
                               <span class="n">return_slope</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span></div>
</div>

<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<div class="viewcode-block" id="AutoDetectionPowerSlope.time_test_power_calc_itter">
<a class="viewcode-back" href="../../../autoapi/komanawa/gw_detect_power/index.html#komanawa.gw_detect_power.change_detection_slope.AutoDetectionPowerSlope.time_test_power_calc_itter">[docs]</a>
<div class="viewcode-block" id="DetectionPowerSlope.time_test_power_calc_itter">
<a class="viewcode-back" href="../../../autoapi/komanawa/gw_detect_power/index.html#komanawa.gw_detect_power.change_detection_slope.DetectionPowerSlope.time_test_power_calc_itter">[docs]</a>
<span class="sd">        :param y: data</span>
<span class="sd">        :param expected_slope: expected slope values</span>
<span class="sd">        :param imax: not used</span>
<span class="sd">        :param imin: not used</span>
<span class="sd">        :param return_slope: dummy</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_sims</span><span class="p">,</span> <span class="n">n_samples</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">if</span> <span class="nb">callable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mpmk_check_step</span><span class="p">):</span>
            <span class="n">use_check_step</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpmk_check_step</span><span class="p">(</span><span class="n">n_samples</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">use_check_step</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpmk_check_step</span>
        <span class="k">assert</span> <span class="p">(</span>
                <span class="p">(</span><span class="n">n_samples</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_samples</span><span class="p">)</span>
                <span class="ow">and</span> <span class="p">(</span><span class="n">n_samples</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kendall_mp_min_part_size</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">kendall_mp_nparts</span><span class="p">)</span>
        <span class="p">),</span> <span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">n_samples</span><span class="si">=}</span><span class="s1"> must be greater than min_samples=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">min_samples</span><span class="si">}</span><span class="s1">,&#39;</span>
            <span class="sa">f</span><span class="s1">&#39; or nparts=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">kendall_mp_nparts</span><span class="si">}</span><span class="s1"> * min_part_size=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">kendall_mp_min_part_size</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">power</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">window</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">efficent_mode</span><span class="p">:</span>
            <span class="n">mpmk</span> <span class="o">=</span> <span class="n">MultiPartKendall</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">true_data</span><span class="p">,</span> <span class="n">nparts</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">kendall_mp_nparts</span><span class="p">,</span>
                                    <span class="n">expect_part</span><span class="o">=</span><span class="n">expected_slope</span><span class="p">,</span> <span class="n">min_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">kendall_mp_min_part_size</span><span class="p">,</span>
                                    <span class="n">alpha</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">min_p_value</span><span class="p">,</span> <span class="n">no_trend_alpha</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">kendall_mp_no_trend_alpha</span><span class="p">,</span></div>
</div>

                                    <span class="n">check_step</span><span class="o">=</span><span class="n">use_check_step</span><span class="p">,</span> <span class="n">check_window</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
            <span class="n">best</span> <span class="o">=</span> <span class="n">mpmk</span><span class="o">.</span><span class="n">get_maxz_breakpoints</span><span class="p">(</span><span class="n">raise_on_none</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">best</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># no matches on the True data not worth running the power calc</span>
                <span class="k">return</span> <span class="mf">0.</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_sims</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">best</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;multiple best breakpoints returned, cannot use efficent mode: </span><span class="si">{</span><span class="n">best</span><span class="si">}</span><span class="s1">, &#39;</span>
                              <span class="sa">f</span><span class="s1">&#39;reverting to original mode&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">best</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">best</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">best</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">kendall_mp_nparts</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="sa">f</span><span class="s1">&#39;shouldnt get here &#39;</span>
                                                                 <span class="sa">f</span><span class="s1">&#39;best breakpoints must have&#39;</span>
                                                                 <span class="sa">f</span><span class="s1">&#39; length </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">kendall_mp_nparts</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="n">window</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">part</span><span class="p">,</span> <span class="n">bp</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">kendall_mp_nparts</span><span class="p">),</span> <span class="n">best</span><span class="p">):</span>
                    <span class="n">delta</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mpmpk_efficent_min</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">use_check_step</span><span class="p">,</span>
                                <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mpmk_window</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">true_data</span><span class="p">))))</span>
                    <span class="n">wmin</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">kendall_mp_min_part_size</span><span class="p">,</span> <span class="n">bp</span> <span class="o">-</span> <span class="n">delta</span><span class="p">)</span>
                    <span class="n">wmax</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">true_data</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">kendall_mp_min_part_size</span><span class="p">,</span>
                               <span class="n">bp</span> <span class="o">+</span> <span class="n">delta</span><span class="p">)</span>
                    <span class="n">window</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">wmin</span><span class="p">,</span> <span class="n">wmax</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">y0</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">print_freq</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">print_freq</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">idv</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s1"> of </span><span class="si">{</span><span class="n">n_sims</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">mpmk</span> <span class="o">=</span> <span class="n">MultiPartKendall</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">y0</span><span class="p">,</span> <span class="n">nparts</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">kendall_mp_nparts</span><span class="p">,</span>
                                    <span class="n">expect_part</span><span class="o">=</span><span class="n">expected_slope</span><span class="p">,</span> <span class="n">min_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">kendall_mp_min_part_size</span><span class="p">,</span>
                                    <span class="n">alpha</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">min_p_value</span><span class="p">,</span> <span class="n">no_trend_alpha</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">kendall_mp_no_trend_alpha</span><span class="p">,</span>
                                    <span class="n">check_step</span><span class="o">=</span><span class="n">use_check_step</span><span class="p">,</span> <span class="n">check_window</span><span class="o">=</span><span class="n">window</span><span class="p">)</span>
            <span class="n">power</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mpmk</span><span class="o">.</span><span class="n">acceptable_matches</span><span class="o">.</span><span class="n">any</span><span class="p">())</span>

        <span class="n">power_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">power</span><span class="p">)</span>
        <span class="n">power_out</span> <span class="o">=</span> <span class="n">power_array</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="n">n_sims</span> <span class="o">*</span> <span class="mi">100</span>
        <span class="k">if</span> <span class="n">return_slope</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">power_out</span><span class="p">,</span> <span class="n">power_array</span><span class="p">,</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">power_out</span><span class="p">,</span> <span class="n">power_array</span>

    <span class="k">def</span> <span class="nf">_run_power_calc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">testnitter</span><span class="p">,</span> <span class="n">seed</span><span class="p">,</span> <span class="n">true_conc_ts</span><span class="p">,</span> <span class="n">idv</span><span class="p">,</span> <span class="n">error</span><span class="p">,</span> <span class="n">expect_slope</span><span class="p">,</span> <span class="n">max_conc_val</span><span class="p">,</span>
                        <span class="n">max_conc_time</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">testnitter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;testnitter is expected to be None unless you are testing run times&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">seed</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">seed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">21</span><span class="p">,</span> <span class="mi">54762438</span><span class="p">)</span>

        <span class="n">nsamples</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">true_conc_ts</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">nsamples</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_samples</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;nsamples must be greater than </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">min_samples</span><span class="si">}</span><span class="s1">, you can change the &#39;</span>
                             <span class="sa">f</span><span class="s1">&#39;minimum number of samples in the DetectionPowerCalculator class init&#39;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">true_conc_ts</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(),</span> <span class="s1">&#39;true_conc_ts must be finite&#39;</span>

        <span class="c1"># tile to nsims</span>
        <span class="k">if</span> <span class="n">testnitter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">rand_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">testnitter</span><span class="p">,</span> <span class="n">nsamples</span><span class="p">)</span>
            <span class="n">conc_with_noise</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">true_conc_ts</span><span class="p">,</span> <span class="n">testnitter</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">rand_shape</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rand_shape</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nsims</span><span class="p">,</span> <span class="n">nsamples</span><span class="p">)</span>
            <span class="n">conc_with_noise</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">true_conc_ts</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsims</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">rand_shape</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>

        <span class="c1"># generate noise</span>
        <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
        <span class="n">all_seeds</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">21</span><span class="p">,</span> <span class="mi">54762438</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
        <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">all_seeds</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
        <span class="n">noise</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">error</span><span class="p">,</span> <span class="n">rand_shape</span><span class="p">)</span>
        <span class="n">conc_with_noise</span> <span class="o">+=</span> <span class="n">noise</span>

        <span class="c1"># run slope test</span>
        <span class="n">power</span><span class="p">,</span> <span class="n">significant</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">power_test</span><span class="p">(</span><span class="n">idv</span><span class="p">,</span> <span class="n">conc_with_noise</span><span class="p">,</span>
                                             <span class="n">expected_slope</span><span class="o">=</span><span class="n">expect_slope</span><span class="p">,</span>  <span class="c1"># just used for sign</span>
                                             <span class="n">imax</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">true_conc_ts</span><span class="p">),</span> <span class="n">imin</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">true_conc_ts</span><span class="p">),</span>
                                             <span class="n">true_data</span><span class="o">=</span><span class="n">true_conc_ts</span><span class="p">,</span>
                                             <span class="n">return_slope</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="n">out</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">({</span><span class="s1">&#39;idv&#39;</span><span class="p">:</span> <span class="n">idv</span><span class="p">,</span>
                         <span class="s1">&#39;power&#39;</span><span class="p">:</span> <span class="n">power</span><span class="p">,</span>
                         <span class="s1">&#39;max_conc&#39;</span><span class="p">:</span> <span class="n">max_conc_val</span><span class="p">,</span>
                         <span class="s1">&#39;max_conc_time&#39;</span><span class="p">:</span> <span class="n">max_conc_time</span><span class="p">,</span>
                         <span class="s1">&#39;error&#39;</span><span class="p">:</span> <span class="n">error</span><span class="p">,</span>
                         <span class="s1">&#39;seed&#39;</span><span class="p">:</span> <span class="n">seed</span><span class="p">,</span>
                         <span class="s1">&#39;python_error&#39;</span><span class="p">:</span> <span class="kc">None</span>
                         <span class="p">})</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">out</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>

        <span class="n">out_data</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">out_data</span><span class="p">[</span><span class="s1">&#39;power&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">out</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">return_true_conc</span><span class="p">:</span>
            <span class="n">out_data</span><span class="p">[</span><span class="s1">&#39;true_conc&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">true_conc_ts</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;true_conc&#39;</span><span class="p">])</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">return_noisy_conc_itters</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">only_significant_noisy</span><span class="p">:</span>
                <span class="n">conc_with_noise</span> <span class="o">=</span> <span class="n">conc_with_noise</span><span class="p">[</span><span class="n">significant</span><span class="p">]</span>
                <span class="n">significant</span> <span class="o">=</span> <span class="n">significant</span><span class="p">[</span><span class="n">significant</span><span class="p">]</span>
            <span class="n">outn</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">return_noisy_conc_itters</span><span class="p">,</span> <span class="n">conc_with_noise</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">out_data</span><span class="p">[</span><span class="s1">&#39;noisy_conc&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">conc_with_noise</span><span class="p">[:</span><span class="n">outn</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
                                                  <span class="n">columns</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">outn</span><span class="p">))</span>
            <span class="n">out_data</span><span class="p">[</span><span class="s1">&#39;significant&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">significant</span><span class="p">[:</span><span class="n">outn</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">out_data</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">out_data</span> <span class="o">=</span> <span class="n">out_data</span><span class="p">[</span><span class="s1">&#39;power&#39;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">out_data</span>

<div class="viewcode-block" id="DetectionPowerSlope.power_calc">
<a class="viewcode-back" href="../../../autoapi/komanawa/gw_detect_power/index.html#komanawa.gw_detect_power.change_detection_slope.DetectionPowerSlope.power_calc">[docs]</a>
    <span class="k">def</span> <span class="nf">power_calc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idv</span><span class="p">,</span> <span class="n">error</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">true_conc_ts</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                   <span class="n">seed</span><span class="p">:</span> <span class="p">{</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">}</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">testnitter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        calculate the slope detection power of a given concentration time series, note the power is calculated using the sampling frequency of the true_conc_ts, if you want to test the power at a different sampling frequency then you should resample the true_conc_ts before passing it to this function</span>

<span class="sd">        :param idv: identifiers for the power calc sites, passed straight through to the output</span>
<span class="sd">        :param error: standard deviation of the noise</span>
<span class="sd">        :param true_conc_ts: the true concentration timeseries for the power calc</span>
<span class="sd">        :param seed: int or None for random seed</span>
<span class="sd">        :param testnitter: None (usually) or a different nitter then self.niter for testing run times</span>
<span class="sd">        :param kwargs: any other kwargs to pass directly to the output Series</span>
<span class="sd">        :return: pd.Series with the power calc results note power is percent 0-100</span>

<span class="sd">        Possible other dataframes if self.return_true_conc is True or self.return_noisy_conc_itters &gt; 0 in which case a dictionary will be returned:</span>

<span class="sd">        {&#39;power&#39;: power_df, # always</span>
<span class="sd">        &#39;true_conc&#39;: true_conc_ts, if self.return_true_conc is True</span>
<span class="sd">        &#39;noisy_conc&#39; : noisy_conc_ts, if self.return_noisy_conc_itters &gt; 0</span>
<span class="sd">        }</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="n">true_conc_ts</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="n">max_conc_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">true_conc_ts</span><span class="p">)</span>
        <span class="n">max_conc_time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">true_conc_ts</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">expect_slope</span> <span class="o">==</span> <span class="s1">&#39;auto&#39;</span><span class="p">:</span>
            <span class="n">power</span><span class="p">,</span> <span class="n">significant</span><span class="p">,</span> <span class="n">expect_slope</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">power_test</span><span class="p">(</span><span class="s1">&#39;auto_slope_finder&#39;</span><span class="p">,</span>
                                                               <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">true_conc_ts</span><span class="p">)[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:],</span>
                                                               <span class="n">expected_slope</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">imax</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">true_conc_ts</span><span class="p">),</span>
                                                               <span class="n">imin</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">true_conc_ts</span><span class="p">),</span> <span class="n">true_data</span><span class="o">=</span><span class="n">true_conc_ts</span><span class="p">,</span>
                                                               <span class="n">return_slope</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">expect_slope</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expect_slope</span>

        <span class="n">outdata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_run_power_calc</span><span class="p">(</span><span class="n">testnitter</span><span class="o">=</span><span class="n">testnitter</span><span class="p">,</span>
                                       <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">,</span>
                                       <span class="n">true_conc_ts</span><span class="o">=</span><span class="n">true_conc_ts</span><span class="p">,</span>
                                       <span class="n">idv</span><span class="o">=</span><span class="n">idv</span><span class="p">,</span>
                                       <span class="n">error</span><span class="o">=</span><span class="n">error</span><span class="p">,</span>
                                       <span class="n">expect_slope</span><span class="o">=</span><span class="n">expect_slope</span><span class="p">,</span>
                                       <span class="n">max_conc_val</span><span class="o">=</span><span class="n">max_conc_val</span><span class="p">,</span>
                                       <span class="n">max_conc_time</span><span class="o">=</span><span class="n">max_conc_time</span><span class="p">,</span>
                                       <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">outdata</span></div>


<div class="viewcode-block" id="DetectionPowerSlope.mulitprocess_power_calcs">
<a class="viewcode-back" href="../../../autoapi/komanawa/gw_detect_power/index.html#komanawa.gw_detect_power.change_detection_slope.DetectionPowerSlope.mulitprocess_power_calcs">[docs]</a>
    <span class="k">def</span> <span class="nf">mulitprocess_power_calcs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                 <span class="n">outpath</span><span class="p">:</span> <span class="p">{</span><span class="n">Path</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="nb">str</span><span class="p">},</span>
                                 <span class="n">idv_vals</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                                 <span class="n">error_vals</span><span class="p">:</span> <span class="p">{</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">float</span><span class="p">},</span>
                                 <span class="n">true_conc_ts_vals</span><span class="p">:</span> <span class="p">{</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">list</span><span class="p">},</span>
                                 <span class="n">seed_vals</span><span class="p">:</span> <span class="p">{</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">}</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                 <span class="n">run</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">debug_mode</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                 <span class="o">**</span><span class="n">kwargs</span>
                                 <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        multiprocessing wrapper for power_calc, see power_calc for details note that if a given run raises and exception the traceback for the exception will be included in the returned dataset under the column &#39;python_error&#39; if &#39;python_error&#39; is None then the run was successful to change the number of cores used pass n_cores to the constructor init</span>

<span class="sd">        :param outpath: path to save results to or None (no save)</span>
<span class="sd">        :param idv_vals: id values for each simulation</span>

<span class="sd">        All values from here on out should be either a single value or an array of values with the same shape as id_vals</span>

<span class="sd">        :param error_vals: standard deviation of noise to add for each simulation</span>
<span class="sd">        :param true_conc_ts_vals: the true concentration time series for each simulation, note that this can be a list of arrays of different lengths for each simulation, as Numpy does not support jagged arrays</span>
<span class="sd">        :param seed: ndarray (integer seeds), None (no seeds), or int (1 seed for all simulations)</span>
<span class="sd">        :param run: if True run the simulations, if False just build  the run_dict and print the number of simulations</span>
<span class="sd">        :param debug_mode: if True run as single process to allow for easier debugging</span>
<span class="sd">        :param kwargs: any other kwargs to pass directly to the output dataframe</span>
<span class="sd">        :return: dataframe with input data and the results of all of the power calcs. note power is percent 0-100</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">use_kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">error_vals</span><span class="o">=</span><span class="n">error_vals</span><span class="p">,</span>
                          <span class="n">true_conc_ts_vals</span><span class="o">=</span><span class="n">true_conc_ts_vals</span><span class="p">,</span>
                          <span class="n">seed_vals</span><span class="o">=</span><span class="n">seed_vals</span><span class="p">,</span>
                          <span class="o">**</span><span class="n">kwargs</span>
                          <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_run_multiprocess_pass_conc</span><span class="p">(</span><span class="n">outpath</span><span class="p">,</span> <span class="n">idv_vals</span><span class="p">,</span> <span class="n">run</span><span class="p">,</span> <span class="n">debug_mode</span><span class="p">,</span> <span class="n">use_kwargs</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="AutoDetectionPowerSlope">
<a class="viewcode-back" href="../../../autoapi/komanawa/gw_detect_power/index.html#komanawa.gw_detect_power.change_detection_slope.AutoDetectionPowerSlope">[docs]</a>
<span class="k">class</span> <span class="nc">AutoDetectionPowerSlope</span><span class="p">(</span><span class="n">DetectionPowerSlope</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class is used to calculate the slope detection power of an auto created concentration</span>
<span class="sd">    time series. The user specifies an initial concentration, a target concentration. Other parameters</span>
<span class="sd">    include groundwater age distribution models and parameters, implementation time and the slope of</span>
<span class="sd">    the previous data. The user then specifies the sampling duration, and frequency.</span>
<span class="sd">    The power is calculated by adding many noise realisations to the concentration data and then running one of</span>
<span class="sd">    multiple change detection tests on the noisy data.</span>

<span class="sd">    The Power is calculated as the percentage (0-100) of simulations which detect a slope.</span>

<span class="sd">    :param significance_mode: significance mode to use, options:</span>

<span class="sd">             * linear-regression: linear regression of the concentration data from time 0 to the end change detected if p &lt; min_p_value</span>
<span class="sd">             * linear-regression-from-[max|min]: linear regression of the concentration data from the maximum concentration of the noise free concentration data to the end change detected if p &lt; min_p_value</span>
<span class="sd">             * mann-kendall: mann-kendall test of the concentration data from time 0 to the end, change detected if p &lt; min_p_value</span>
<span class="sd">             * mann-kendall-from-[max|min]: mann-kendall test of the concentration data from the maximum/minimum of the noisefree concentration data to the end, change detected if p &lt; min_p_value</span>
<span class="sd">             * n-section-mann-kendall: 2+ part mann-kendall test to identify change points. if change points are detected then a change is detected</span>
<span class="sd">             * pettitt-test: pettitt test to identify change points. if change points are detected then a change is detected</span>

<span class="sd">    :param nsims: number of noise simulations to run for each change detection (e.g. nsims=1000, power= number of detected changes/1000 noise simulations)</span>
<span class="sd">    :param min_p_value: minimum p value to consider a change detected</span>
<span class="sd">    :param min_samples: minimum number of samples required, less than this number of samples will raise an exception</span>
<span class="sd">    :param expect_slope: expected slope of the concentration data, use depends on significance mode:</span>

<span class="sd">                          * linear-regression, linear-regression-from-max, mann-kendall, mann-kendall-from-max: one of 1 (increasing), -1 (decreasing), or &#39;auto&#39; will match the slope of the concentration data before noise is added</span>
<span class="sd">                          * n-section-mann-kendall: expected trend in each part of the time series (1 increasing, -1 decreasing, 0 no trend)</span>
<span class="sd">                          * pettitt-test: not used.</span>

<span class="sd">    :param efficent_mode: bool, default = True, if True then</span>

<span class="sd">                         * For linear regression and MannKendall based tests:  run the test on the noise free data to see if any change can be detected, if no change is detected then the test will not be on the noisy data</span>
<span class="sd">                         * For MultiPartMannKendall test: the test will be run on the noise free data to detect best change points and then the test will be run on the noisy data for a smaller window centered on the True change point see: &quot;mpmk_efficent_min&quot; and &quot;mpmk_window&quot;</span>
<span class="sd">                         * For Pettitt Test:  Not implemented, will be ignored and a waring passed</span>

<span class="sd">    :param nparts: number of parts to use for the n-section-mann-kendall test (not used for other tests)</span>
<span class="sd">    :param min_part_size: minimum number of samples in each part for the n-section-mann-kendall test (not used for other tests)</span>
<span class="sd">    :param no_trend_alpha: alpha value to use for the no trend sections in the n-section-mann-kendall test trend less sections are only accepted if p &gt; no_trend_alpha (not used for other tests)</span>
<span class="sd">    :param mpmk_check_step: int or function, default = 1, number of samples to check for a change point in the MultiPartMannKendall test, used in both efficent_mode=True and efficent_mode=False if mpmk is a function it must take a single argument (n, number of samples) and return an integer check step</span>
<span class="sd">    :param mpmk_efficent_min: int, default = 10, minimum number of possible change points to assess only used if efficent_mode = True  The minimum number of breakpoints to test (mpmk_efficent_min) is always respected (i.e. if the window size is less than the minimum number of breakpoints to test, then the window size will be increased to the minimum number of breakpoints to test, but the space between breakpoints will still be defined by check_step). You can specify the exact number of breakpoints to check by setting mpmk_efficent_min=n breakpoints and setting mpmk_window=0</span>
<span class="sd">    :param mpmk_window: float, default = 0.05, define the window around the true detected change point to run the MultiPartMannKendall.  The detction window is defined as: (cp - mpmk_window*n, cp + mpmk_window*n) where cp is the detected change point and n is the number of samples in the time series Where both a mpmk_window and a check_step&gt;1 is passed the mpmk_window will be used to define the window size and the check_step will be used to define the step size within the window.</span>
<span class="sd">    :param nsims_pettit: number of simulations to run for calculating the pvalue of the pettitt test (not used for other tests)</span>
<span class="sd">    :param ncores: number of cores to use for multiprocessing, None will use all available cores</span>
<span class="sd">    :param log_level: logging level for multiprocessing subprocesses</span>
<span class="sd">    :param return_true_conc: return the true concentration time series for each simulation with power calcs (not supported with multiprocessing power calcs)</span>
<span class="sd">    :param return_noisy_conc_itters: int &lt;= nsims, default = 0 Number of noisy simulations to return if 0 then no noisy simulations are returned, not supported with multiprocessing power calcs</span>
<span class="sd">    :param only_significant_noisy: bool if True then only return noisy simulations where a change was detected if there are fewer noisy simulations with changes detected than return_noisy_conc_itters all significant simulations will be returned. if there are no noisy simulations with changes detected then and empty dataframe is returned</span>
<span class="sd">    :param print_freq: None or int:  if None then no progress will be printed, if int then progress will be printed every print_freq simulations (n%print_freq==0)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">implemented_mrt_models</span> <span class="o">=</span> <span class="p">(</span>
        <span class="s1">&#39;piston_flow&#39;</span><span class="p">,</span>
        <span class="s1">&#39;binary_exponential_piston_flow&#39;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">_auto_mode</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">condensed_mode</span> <span class="o">=</span> <span class="kc">False</span>

<div class="viewcode-block" id="AutoDetectionPowerSlope.set_condensed_mode">
<a class="viewcode-back" href="../../../autoapi/komanawa/gw_detect_power/index.html#komanawa.gw_detect_power.change_detection_slope.AutoDetectionPowerSlope.set_condensed_mode">[docs]</a>
    <span class="k">def</span> <span class="nf">set_condensed_mode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                           <span class="n">target_conc_per</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                           <span class="n">initial_conc_per</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                           <span class="n">error_per</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                           <span class="n">prev_slope_per</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                           <span class="n">max_conc_lim_per</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                           <span class="n">min_conc_lim_per</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                           <span class="n">mrt_per</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                           <span class="n">mrt_p1_per</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                           <span class="n">frac_p1_per</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                           <span class="n">f_p1_per</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                           <span class="n">f_p2_per</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        set calculator to condense the number of runs based by rounding the inputs to a specified precision</span>

<span class="sd">        :param target_conc_per: precision to round target_conc to (2 = 0.01)</span>
<span class="sd">        :param initial_conc_per: precision to round initial_conc to (2 = 0.01)</span>
<span class="sd">        :param error_per: precision to round error to (2 = 0.01)</span>
<span class="sd">        :param prev_slope_per: precision to round previous_slope to (2 = 0.01)</span>
<span class="sd">        :param max_conc_lim_per: precision to round max_conc_lim to (2 = 0.01)</span>
<span class="sd">        :param min_conc_lim_per: precision to round min_conc_lim to (2 = 0.01)</span>
<span class="sd">        :param mrt_per: precision to round mrt to</span>
<span class="sd">        :param mrt_p1_per: precision to round mrt_p1 to</span>
<span class="sd">        :param frac_p1_per: precision to round frac_p1 to</span>
<span class="sd">        :param f_p1_per: precision to round f_p1 to</span>
<span class="sd">        :param f_p2_per: precision to round f_p2 to</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">condensed_mode</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">target_conc_per</span> <span class="o">=</span> <span class="n">target_conc_per</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initial_conc_per</span> <span class="o">=</span> <span class="n">initial_conc_per</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">error_per</span> <span class="o">=</span> <span class="n">error_per</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prev_slope_per</span> <span class="o">=</span> <span class="n">prev_slope_per</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_conc_lim_per</span> <span class="o">=</span> <span class="n">max_conc_lim_per</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_conc_lim_per</span> <span class="o">=</span> <span class="n">min_conc_lim_per</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mrt_per</span> <span class="o">=</span> <span class="n">mrt_per</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mrt_p1_per</span> <span class="o">=</span> <span class="n">mrt_p1_per</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">frac_p1_per</span> <span class="o">=</span> <span class="n">frac_p1_per</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">f_p1_per</span> <span class="o">=</span> <span class="n">f_p1_per</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">f_p2_per</span> <span class="o">=</span> <span class="n">f_p2_per</span></div>


<div class="viewcode-block" id="AutoDetectionPowerSlope.power_calc">
<a class="viewcode-back" href="../../../autoapi/komanawa/gw_detect_power/index.html#komanawa.gw_detect_power.change_detection_slope.AutoDetectionPowerSlope.power_calc">[docs]</a>
    <span class="k">def</span> <span class="nf">power_calc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idv</span><span class="p">,</span> <span class="n">error</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">mrt_model</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">samp_years</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">samp_per_year</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                   <span class="n">implementation_time</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">initial_conc</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">target_conc</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">prev_slope</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
                   <span class="n">max_conc_lim</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">min_conc_lim</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">mrt</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
                   <span class="c1"># options for binary_exponential_piston_flow model</span>
                   <span class="n">mrt_p1</span><span class="p">:</span> <span class="p">{</span><span class="nb">float</span><span class="p">,</span> <span class="kc">None</span><span class="p">}</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">frac_p1</span><span class="p">:</span> <span class="p">{</span><span class="nb">float</span><span class="p">,</span> <span class="kc">None</span><span class="p">}</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">f_p1</span><span class="p">:</span> <span class="p">{</span><span class="nb">float</span><span class="p">,</span> <span class="kc">None</span><span class="p">}</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                   <span class="n">f_p2</span><span class="p">:</span> <span class="p">{</span><span class="nb">float</span><span class="p">,</span> <span class="kc">None</span><span class="p">}</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                   <span class="c1"># options for the model run</span>
                   <span class="n">seed</span><span class="p">:</span> <span class="p">{</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">}</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                   <span class="n">testnitter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                   <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        calculate the detection power for a given set of parameters</span>

<span class="sd">        :param idv: identifiers for the power calc sites, passed straight through to the output</span>
<span class="sd">        :param error: standard deviation of the noise</span>
<span class="sd">        :param mrt_model: the model to use for the mean residence time options:</span>

<span class="sd">                          * &#39;piston_flow&#39;: use the piston flow model (no mixing, default)</span>
<span class="sd">                          * &#39;binary_exponential_piston_flow&#39;: use the binary exponential piston flow model for unitary exponential_piston_flow model set frac_1 = 1 and mrt_p1 = mrt for no lag, set mrt=0, mrt_model=&#39;piston_flow&#39;</span>

<span class="sd">        :param samp_years: number of years to sample</span>
<span class="sd">        :param samp_per_year: number of samples to collect each year</span>
<span class="sd">        :param implementation_time: number of years over which reductions are implemented</span>
<span class="sd">        :param initial_conc: initial median value of the concentration</span>
<span class="sd">        :param target_conc: target concentration to reduce to</span>
<span class="sd">        :param prev_slope: slope of the previous data (e.g. prior to the initial concentration)</span>
<span class="sd">        :param max_conc_lim: maximum concentration limit user specified or None (default)</span>
<span class="sd">        :param min_conc_lim: minimum concentration limit for the source, only used for the binary_exponential_piston_flow model)</span>
<span class="sd">        :param mrt: the mean residence time of the site</span>

<span class="sd">        Options for binary_exponential_piston_flow model:</span>

<span class="sd">        :param mrt_p1: the mean residence time of the first piston flow model (only used for binary_exponential_piston_flow model)</span>
<span class="sd">        :param frac_p1: the fraction of the first piston flow model (only used for binary_exponential_piston_flow model)</span>
<span class="sd">        :param f_p1: the fraction of the first piston flow model (only used for binary_exponential_piston_flow model)</span>
<span class="sd">        :param f_p2: the fraction of the first piston flow model (only used for binary_exponential_piston_flow model)</span>

<span class="sd">        Model run options:</span>

<span class="sd">        :param seed: int or None for random seed</span>
<span class="sd">        :param testnitter: None (usually) or a different nitter then self.niter for testing run times</span>
<span class="sd">        :param kwargs: kwargs passed to the output series (e.g. region=&#39;temp&#39; will yield a &#39;region&#39; index with a value of &#39;temp&#39;)</span>
<span class="sd">        :return: pd.Seris with the power calc results note power is percent 0-100 Possible other dataframes if self.return_true_conc is True or self.return_noisy_conc_itters &gt; 0 in which case a dictionary will be returned:</span>

<span class="sd">        {&#39;power&#39;: power_df, # always</span>
<span class="sd">        &#39;true_conc&#39;: true_conc_ts, if self.return_true_conc is True</span>
<span class="sd">        &#39;noisy_conc&#39; : noisy_conc_ts, if self.return_noisy_conc_itters &gt; 0</span>
<span class="sd">        }</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">testnitter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;testnitter is expected to be None unless you are testing run times&#39;</span><span class="p">)</span>

        <span class="k">assert</span> <span class="n">mrt_model</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">implemented_mrt_models</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;mrt_model must be one of: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">implemented_mrt_models</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="k">assert</span> <span class="n">pd</span><span class="o">.</span><span class="n">api</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">is_integer</span><span class="p">(</span><span class="n">samp_years</span><span class="p">),</span> <span class="s1">&#39;samp_years must be an integer &#39;</span>
        <span class="k">assert</span> <span class="n">pd</span><span class="o">.</span><span class="n">api</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">is_integer</span><span class="p">(</span><span class="n">samp_per_year</span><span class="p">),</span> <span class="s1">&#39;samp_per_year must be an integer &#39;</span>
        <span class="k">assert</span> <span class="n">pd</span><span class="o">.</span><span class="n">api</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">is_number</span><span class="p">(</span><span class="n">initial_conc</span><span class="p">),</span> <span class="s1">&#39;initial_conc must be a number &#39;</span>
        <span class="k">assert</span> <span class="n">pd</span><span class="o">.</span><span class="n">api</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">is_number</span><span class="p">(</span><span class="n">target_conc</span><span class="p">),</span> <span class="s1">&#39;target_conc must be a number &#39;</span>
        <span class="k">assert</span> <span class="n">pd</span><span class="o">.</span><span class="n">api</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">is_number</span><span class="p">(</span><span class="n">prev_slope</span><span class="p">),</span> <span class="s1">&#39;prev_slope must be a number &#39;</span>
        <span class="k">assert</span> <span class="n">pd</span><span class="o">.</span><span class="n">api</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">is_number</span><span class="p">(</span><span class="n">max_conc_lim</span><span class="p">),</span> <span class="s1">&#39;max_conc must be a number &#39;</span>
        <span class="k">assert</span> <span class="n">max_conc_lim</span> <span class="o">&gt;=</span> <span class="n">initial_conc</span><span class="p">,</span> <span class="s1">&#39;max_conc must be greater than or equal to initial_conc&#39;</span>
        <span class="k">assert</span> <span class="n">max_conc_lim</span> <span class="o">&gt;=</span> <span class="n">target_conc</span><span class="p">,</span> <span class="s1">&#39;max_conc must be greater than or equal to target_conc&#39;</span>
        <span class="k">assert</span> <span class="n">pd</span><span class="o">.</span><span class="n">api</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">is_integer</span><span class="p">(</span><span class="n">implementation_time</span><span class="p">)</span>

        <span class="c1"># mange lag</span>
        <span class="k">if</span> <span class="n">mrt_model</span> <span class="o">==</span> <span class="s1">&#39;piston_flow&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">significance_mode</span> <span class="o">==</span> <span class="s1">&#39;pettitt-test&#39;</span> <span class="ow">and</span> <span class="n">mrt</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;using the Pettitt test with lagged data can cause some weird results, we do&#39;</span>
                              <span class="s1">&#39;not recommend using this combination&#39;</span><span class="p">)</span>

            <span class="n">true_conc_ts</span><span class="p">,</span> <span class="n">max_conc_val</span><span class="p">,</span> <span class="n">max_conc_time</span><span class="p">,</span> <span class="n">mrt_p2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">truets_from_piston_flow</span><span class="p">(</span><span class="n">mrt</span><span class="p">,</span>
                                                                                             <span class="n">initial_conc</span><span class="p">,</span> <span class="n">target_conc</span><span class="p">,</span>
                                                                                             <span class="n">prev_slope</span><span class="p">,</span> <span class="n">max_conc_lim</span><span class="p">,</span>
                                                                                             <span class="n">samp_per_year</span><span class="p">,</span> <span class="n">samp_years</span><span class="p">,</span>
                                                                                             <span class="n">implementation_time</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">expect_slope</span> <span class="o">==</span> <span class="s1">&#39;auto&#39;</span><span class="p">:</span>
                <span class="n">expect_slope</span> <span class="o">=</span> <span class="p">(</span><span class="n">target_conc</span> <span class="o">-</span> <span class="n">initial_conc</span><span class="p">)</span> <span class="o">/</span> <span class="n">implementation_time</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">expect_slope</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expect_slope</span>

        <span class="k">elif</span> <span class="n">mrt_model</span> <span class="o">==</span> <span class="s1">&#39;binary_exponential_piston_flow&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">significance_mode</span> <span class="o">==</span> <span class="s1">&#39;pettitt-test&#39;</span> <span class="ow">and</span> <span class="n">mrt</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;using the Pettitt test with lagged data can cause some weird results, we do&#39;</span>
                              <span class="s1">&#39;not recommend using this combination&#39;</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">age_tools_imported</span><span class="p">,</span> <span class="p">(</span>
                <span class="s1">&#39;cannot run binary_exponential_piston_flow model, age_tools not installed&#39;</span>
                <span class="s1">&#39;to install run:</span><span class="se">\n</span><span class="s1">&#39;</span>
                <span class="s1">&#39;pip install git+https://github.com/Komanawa-Solutions-Ltd/gw_age_tools&#39;</span><span class="p">)</span>
            <span class="n">tvs</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;mrt_p1&#39;</span><span class="p">,</span> <span class="s1">&#39;frac_p1&#39;</span><span class="p">,</span> <span class="s1">&#39;f_p1&#39;</span><span class="p">,</span> <span class="s1">&#39;f_p2&#39;</span><span class="p">,</span> <span class="s1">&#39;min_conc_lim&#39;</span><span class="p">]</span>
            <span class="n">bad</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tvs</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">eval</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">bad</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bad</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;for binary_exponential_piston_flow model the following must be specified: </span><span class="si">{</span><span class="n">bad</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

            <span class="p">(</span><span class="n">true_conc_ts</span><span class="p">,</span> <span class="n">max_conc_val</span><span class="p">,</span>
             <span class="n">max_conc_time</span><span class="p">,</span> <span class="n">mrt_p2</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">truets_from_binary_exp_piston_flow</span><span class="p">(</span>
                <span class="n">mrt</span><span class="p">,</span> <span class="n">mrt_p1</span><span class="p">,</span> <span class="n">frac_p1</span><span class="p">,</span> <span class="n">f_p1</span><span class="p">,</span> <span class="n">f_p2</span><span class="p">,</span>
                <span class="n">initial_conc</span><span class="p">,</span> <span class="n">target_conc</span><span class="p">,</span> <span class="n">prev_slope</span><span class="p">,</span> <span class="n">max_conc_lim</span><span class="p">,</span> <span class="n">min_conc_lim</span><span class="p">,</span>
                <span class="n">samp_per_year</span><span class="p">,</span> <span class="n">samp_years</span><span class="p">,</span> <span class="n">implementation_time</span><span class="p">,</span>
                <span class="n">return_extras</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">expect_slope</span> <span class="o">==</span> <span class="s1">&#39;auto&#39;</span><span class="p">:</span>
                <span class="n">expect_slope</span> <span class="o">=</span> <span class="p">(</span><span class="n">target_conc</span> <span class="o">-</span> <span class="n">initial_conc</span><span class="p">)</span> <span class="o">/</span> <span class="n">implementation_time</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">expect_slope</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expect_slope</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;mrt_model </span><span class="si">{</span><span class="n">mrt_model</span><span class="si">}</span><span class="s1"> not currently implemented&#39;</span><span class="p">)</span>

        <span class="n">out_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_run_power_calc</span><span class="p">(</span><span class="n">testnitter</span><span class="o">=</span><span class="n">testnitter</span><span class="p">,</span>
                                        <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">,</span>
                                        <span class="n">true_conc_ts</span><span class="o">=</span><span class="n">true_conc_ts</span><span class="p">,</span>
                                        <span class="n">idv</span><span class="o">=</span><span class="n">idv</span><span class="p">,</span>
                                        <span class="n">error</span><span class="o">=</span><span class="n">error</span><span class="p">,</span>
                                        <span class="n">expect_slope</span><span class="o">=</span><span class="n">expect_slope</span><span class="p">,</span>
                                        <span class="n">max_conc_val</span><span class="o">=</span><span class="n">max_conc_val</span><span class="p">,</span>
                                        <span class="n">max_conc_time</span><span class="o">=</span><span class="n">max_conc_time</span><span class="p">,</span>
                                        <span class="n">mrt_model</span><span class="o">=</span><span class="n">mrt_model</span><span class="p">,</span>
                                        <span class="n">samp_years</span><span class="o">=</span><span class="n">samp_years</span><span class="p">,</span>
                                        <span class="n">samp_per_year</span><span class="o">=</span><span class="n">samp_per_year</span><span class="p">,</span>
                                        <span class="n">implementation_time</span><span class="o">=</span><span class="n">implementation_time</span><span class="p">,</span>
                                        <span class="n">initial_conc</span><span class="o">=</span><span class="n">initial_conc</span><span class="p">,</span>
                                        <span class="n">target_conc</span><span class="o">=</span><span class="n">target_conc</span><span class="p">,</span>
                                        <span class="n">prev_slope</span><span class="o">=</span><span class="n">prev_slope</span><span class="p">,</span>
                                        <span class="n">max_conc_lim</span><span class="o">=</span><span class="n">max_conc_lim</span><span class="p">,</span>
                                        <span class="n">min_conc_lim</span><span class="o">=</span><span class="n">min_conc_lim</span><span class="p">,</span>
                                        <span class="n">mrt</span><span class="o">=</span><span class="n">mrt</span><span class="p">,</span>
                                        <span class="n">mrt_p1</span><span class="o">=</span><span class="n">mrt_p1</span><span class="p">,</span>
                                        <span class="n">mrt_p2</span><span class="o">=</span><span class="n">mrt_p2</span><span class="p">,</span>
                                        <span class="n">frac_p1</span><span class="o">=</span><span class="n">frac_p1</span><span class="p">,</span>
                                        <span class="n">f_p1</span><span class="o">=</span><span class="n">f_p1</span><span class="p">,</span>
                                        <span class="n">f_p2</span><span class="o">=</span><span class="n">f_p2</span><span class="p">,</span>
                                        <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">out_data</span></div>


<div class="viewcode-block" id="AutoDetectionPowerSlope.mulitprocess_power_calcs">
<a class="viewcode-back" href="../../../autoapi/komanawa/gw_detect_power/index.html#komanawa.gw_detect_power.change_detection_slope.AutoDetectionPowerSlope.mulitprocess_power_calcs">[docs]</a>
    <span class="k">def</span> <span class="nf">mulitprocess_power_calcs</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">outpath</span><span class="p">:</span> <span class="p">{</span><span class="n">Path</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="nb">str</span><span class="p">},</span>
            <span class="n">idv_vals</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
            <span class="n">error_vals</span><span class="p">:</span> <span class="p">{</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">float</span><span class="p">},</span>
            <span class="n">samp_years_vals</span><span class="p">:</span> <span class="p">{</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">int</span><span class="p">},</span>
            <span class="n">samp_per_year_vals</span><span class="p">:</span> <span class="p">{</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">int</span><span class="p">},</span>
            <span class="n">implementation_time_vals</span><span class="p">:</span> <span class="p">{</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">int</span><span class="p">},</span>
            <span class="n">initial_conc_vals</span><span class="p">:</span> <span class="p">{</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">float</span><span class="p">},</span>
            <span class="n">target_conc_vals</span><span class="p">:</span> <span class="p">{</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">float</span><span class="p">},</span>
            <span class="n">prev_slope_vals</span><span class="p">:</span> <span class="p">{</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">float</span><span class="p">},</span>
            <span class="n">max_conc_lim_vals</span><span class="p">:</span> <span class="p">{</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">float</span><span class="p">},</span>
            <span class="n">min_conc_lim_vals</span><span class="p">:</span> <span class="p">{</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">float</span><span class="p">},</span>
            <span class="n">mrt_model_vals</span><span class="p">:</span> <span class="p">{</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">str</span><span class="p">},</span>
            <span class="n">mrt_vals</span><span class="p">:</span> <span class="p">{</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">float</span><span class="p">},</span>
            <span class="n">mrt_p1_vals</span><span class="p">:</span> <span class="p">{</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="kc">None</span><span class="p">}</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">frac_p1_vals</span><span class="p">:</span> <span class="p">{</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="kc">None</span><span class="p">}</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">f_p1_vals</span><span class="p">:</span> <span class="p">{</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="kc">None</span><span class="p">}</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">f_p2_vals</span><span class="p">:</span> <span class="p">{</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="kc">None</span><span class="p">}</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">seed_vals</span><span class="p">:</span> <span class="p">{</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">}</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">run</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">debug_mode</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        multiprocessing wrapper for power_calc, see power_calc for details</span>

<span class="sd">        :param outpath: a path to save the results to or None (no save), df is returned regardless</span>
<span class="sd">        :param idv_vals: an array of identifiers for each simulation</span>
<span class="sd">        :param error_vals: The standard deviation of the noise for each simulation</span>
<span class="sd">        :param samp_years_vals: the number of years to sample</span>
<span class="sd">        :param samp_per_year_vals: The number of samples to collect each year</span>
<span class="sd">        :param implementation_time_vals: The number of years over which reductions are implemented</span>
<span class="sd">        :param initial_conc_vals: The initial concentration for each simulation</span>
<span class="sd">        :param target_conc_vals:  target concentration for the simulation</span>
<span class="sd">        :param prev_slope_vals: previous slope for each simulation</span>
<span class="sd">        :param max_conc_lim_vals: maximum concentration limit for each simulation</span>
<span class="sd">        :param min_conc_lim_vals: minimum concentration limit for the source for each simulation</span>
<span class="sd">        :param mrt_model_vals: mrt model for each simulation</span>
<span class="sd">        :param mrt_vals: mean residence time for each simulation</span>
<span class="sd">        :param mrt_p1_vals: mean residence time of the first piston flow model for each simulation Only used for binary_exponential_piston_flow model</span>
<span class="sd">        :param frac_p1_vals: fraction of the first piston flow model for each simulation Only used for binary_exponential_piston_flow model</span>
<span class="sd">        :param f_p1_vals: the exponential fraction of the first piston flow model for each simulation Only used for binary_exponential_piston_flow model</span>
<span class="sd">        :param f_p2_vals: the exponential fraction of the second piston flow model for each simulation Only used for binary_exponential_piston_flow model</span>
<span class="sd">        :param seed: the random seed for each simulation, one of the following:</span>

<span class="sd">                            * None: no seed, random seed will be generated for each simulation (but it will be recorded in the output dataframe)</span>
<span class="sd">                            * int: a single seed for all simulations</span>
<span class="sd">                            * np.ndarray: an array of seeds, one for each simulation</span>

<span class="sd">        :param run: if True run the simulations, if False just build  the run_dict and print the number of simulations</span>
<span class="sd">        :param debug_mode: if True run as single process to allow for easier debugging</span>
<span class="sd">        :param kwargs: other kwargs to pass directly to the output dataframe must be either a single value or an array of values with the same shape as id_vals</span>
<span class="sd">        :return: dataframe with input data and the results of all of the power calcs. note power is percent 0-100</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">use_kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">error_vals</span><span class="o">=</span><span class="n">error_vals</span><span class="p">,</span>
                          <span class="n">seed_vals</span><span class="o">=</span><span class="n">seed_vals</span><span class="p">,</span>
                          <span class="n">samp_years_vals</span><span class="o">=</span><span class="n">samp_years_vals</span><span class="p">,</span>
                          <span class="n">samp_per_year_vals</span><span class="o">=</span><span class="n">samp_per_year_vals</span><span class="p">,</span>
                          <span class="n">implementation_time_vals</span><span class="o">=</span><span class="n">implementation_time_vals</span><span class="p">,</span>
                          <span class="n">initial_conc_vals</span><span class="o">=</span><span class="n">initial_conc_vals</span><span class="p">,</span>
                          <span class="n">target_conc_vals</span><span class="o">=</span><span class="n">target_conc_vals</span><span class="p">,</span>
                          <span class="n">prev_slope_vals</span><span class="o">=</span><span class="n">prev_slope_vals</span><span class="p">,</span>
                          <span class="n">max_conc_lim_vals</span><span class="o">=</span><span class="n">max_conc_lim_vals</span><span class="p">,</span>
                          <span class="n">min_conc_lim_vals</span><span class="o">=</span><span class="n">min_conc_lim_vals</span><span class="p">,</span>
                          <span class="n">mrt_model_vals</span><span class="o">=</span><span class="n">mrt_model_vals</span><span class="p">,</span>
                          <span class="n">mrt_vals</span><span class="o">=</span><span class="n">mrt_vals</span><span class="p">,</span>
                          <span class="n">mrt_p1_vals</span><span class="o">=</span><span class="n">mrt_p1_vals</span><span class="p">,</span>
                          <span class="n">frac_p1_vals</span><span class="o">=</span><span class="n">frac_p1_vals</span><span class="p">,</span>
                          <span class="n">f_p1_vals</span><span class="o">=</span><span class="n">f_p1_vals</span><span class="p">,</span>
                          <span class="n">f_p2_vals</span><span class="o">=</span><span class="n">f_p2_vals</span><span class="p">,</span>
                          <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_run_multiprocess_auto</span><span class="p">(</span><span class="n">outpath</span><span class="p">,</span> <span class="n">idv_vals</span><span class="p">,</span> <span class="n">run</span><span class="p">,</span> <span class="n">debug_mode</span><span class="p">,</span> <span class="n">use_kwargs</span><span class="p">)</span></div>
</div>

</pre></div>

                </article>
              
              
              
              
              
                <footer class="prev-next-footer">
                  
<div class="prev-next-area">
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
          </footer>
        
      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../../_static/scripts/bootstrap.js?digest=8d27b9dea8ad943066ae"></script>
<script src="../../../_static/scripts/pydata-sphinx-theme.js?digest=8d27b9dea8ad943066ae"></script>

  <footer class="bd-footer">
<div class="bd-footer__inner bd-page-width">
  
    <div class="footer-items__start">
      
        <div class="footer-item">

  <p class="copyright">
    
       Copyright 2024, Matt Dumont.
      <br/>
    
  </p>
</div>
      
        <div class="footer-item">

  <p class="sphinx-version">
    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.2.6.
    <br/>
  </p>
</div>
      
    </div>
  
  
  
    <div class="footer-items__end">
      
        <div class="footer-item">
<p class="theme-version">
  Built with the <a href="https://pydata-sphinx-theme.readthedocs.io/en/stable/index.html">PyData Sphinx Theme</a> 0.15.2.
</p></div>
      
    </div>
  
</div>

  </footer>
  </body>
</html>